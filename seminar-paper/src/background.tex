% background.tex

\chapter{Background}
\thispagestyle{chapterstart}

\section{Post-Quantum Cryptography and CRYSTALS-Dilithium}

The advent of practical quantum computers poses a significant threat to classical cryptographic systems, particularly those based on integer factorization and discrete logarithm problems, such as RSA and Elliptic Curve Cryptography (\ac{ECC}). Quantum algorithms like Shor's algorithm can efficiently solve these problems, rendering traditional public-key cryptosystems insecure in the presence of quantum adversaries.

To address this threat, the National Institute of Standards and Technology (\ac{NIST}) initiated a standardization process to evaluate and select quantum-resistant cryptographic algorithms \cite{NIST24}. Among the leading candidates are lattice-based schemes, which rely on hard mathematical problems believed to be resistant to quantum attacks.

CRYSTALS-Dilithium is one such lattice-based digital signature scheme selected by NIST for standardization \cite{NIST24}. It is built upon the hardness of the Module Learning With Errors (MLWE) problem, involving solving systems of noisy linear equations over polynomial rings. Dilithium operates over the polynomial ring $\mathbb{Z}_q[X]/(X^n + 1)$, where $q$ is a prime modulus and $n$ is a power of two. The scheme leverages structured lattices to achieve efficient key generation, signing, and verification processes.

Key operations in Dilithium include polynomial arithmetic, sampling of random polynomials, and decomposition functions that split polynomial coefficients. These operations are often implemented efficiently using Number Theoretic Transforms (NTTs) and are critical for the scheme's performance and security.

While Dilithium is designed to be secure against quantum adversaries, its implementations can be vulnerable to side-channel attacks if not properly protected, especially during operations involving secret keys and sensitive intermediate values.

\section{Side-Channel Attacks and Vulnerabilities}

Side-channel attacks (\acp{SCA}) exploit physical leakages from cryptographic implementations to extract sensitive information. Unlike traditional cryptanalysis, which targets the mathematical structure of cryptographic algorithms, side-channel analysis leverages information such as timing variations, power consumption, and electromagnetic emissions produced during cryptographic operations.

Common types of side-channel attacks include:

\begin{itemize}
    \item \textbf{Timing Attacks}: Analyze variations in execution time to infer secret data.
    \item \textbf{Power Analysis Attacks}: Measure power consumption during computation; includes Simple Power Analysis (SPA) and Differential Power Analysis (DPA).
    \item \textbf{Electromagnetic Attacks}: Capture electromagnetic emissions to recover secret information.
\end{itemize}

In the context of Dilithium, side-channel vulnerabilities may arise during key generation, signing processes, and functions like decomposition and rejection sampling. Operations involving secret keys and polynomials can leak information if not properly protected. Embedded devices are particularly susceptible due to their physical accessibility and limited computational resources, making it challenging to implement robust countermeasures.

\section{Masking Techniques as Countermeasures}

Masking is a widely used countermeasure against \acp{SCA}, involving splitting sensitive variables into multiple shares so that no single share reveals information about the secret. Computations are performed on these shares independently, reducing the correlation between physical leakages and sensitive data.

There are primarily two types of masking:

\begin{itemize}
    \item \textbf{Boolean Masking}: Uses bitwise XOR operations to mask sensitive values; suitable for algorithms involving logical operations.
    \item \textbf{Arithmetic Masking}: Uses modular addition to mask sensitive values; suitable for algorithms involving arithmetic operations in rings or fields.
\end{itemize}

Higher-order masking extends this concept by splitting sensitive variables into $d$ shares, providing protection against adversaries capable of observing up to $d - 1$ leakages simultaneously. While higher-order masking increases security, it introduces significant computational overhead and complexity, especially for non-linear operations where secure recombination of shares is required.

Implementing masking in schemes like Dilithium involves challenges due to the need to securely perform polynomial arithmetic on masked values. Linear operations, such as addition and subtraction, can be performed share-wise without additional complexity. However, non-linear operations, such as multiplication and modular reduction, require specialized algorithms, often referred to as \emph{masking gadgets}, to securely handle interactions between shares.

\section{Challenges in Masking Dilithium}

Masking Dilithium presents several challenges:

\begin{itemize}
    \item \textbf{Efficiency}: High-order masking increases computational overhead, impacting performance. Optimizing masking techniques is essential to maintain acceptable execution times, especially on embedded devices.
    \item \textbf{Complex Operations}: Functions like the \texttt{Decompose} function and conditional branching based on secret data are complex to mask securely. These operations are critical in Dilithium and require careful treatment to prevent leakages.
    \item \textbf{Resource Constraints}: Embedded devices have limited computational resources and memory. Implementations must be efficient in both time and space to be practical in such environments.
    \item \textbf{Security Guarantees}: Providing formal security guarantees requires rigorous proofs in appropriate models, such as the $t$-probing model. Ensuring that masking schemes are secure under these models adds to the implementation complexity.
\end{itemize}

An additional consideration in Dilithium is the choice between deterministic and randomized signing modes. Deterministic signing derives the secret nonce from the message and secret key, simplifying verification but potentially increasing vulnerability to side-channel attacks if not properly masked. Randomized signing generates a fresh random nonce for each signature, improving side-channel resistance by adding unpredictability but requiring secure random number generation. Randomized signing can reduce the need for masking complex deterministic computations, leading to performance benefits in masked implementations.

Overall, achieving side-channel resistance in Dilithium implementations requires a careful balance between security and performance. Optimizing masking techniques, focusing on critical components, and considering the specific constraints of the target platform are essential for practical and secure deployments.
